<p>For a {{#definition "backward_analysis"}}backward analysis{{/definition}} the algorithm is almost the same:</p>

<p>
    \begin{align}
    & \text{Out} ( \small{\text{EXIT}} ) = v_{\text{EXIT}}; \\
    &    {\bf for} \, ( \text{each block} \: B \: \text{in the CFG} ) \; \text{In}_{B} = \top;    \\
    &    {\bf while} \, ( \text{changes to any} \: \text{In} \: \text{occur} ) \: \{    \\
    &    \quad \quad {\bf for} \, (\text{each block} \: B \: \text{in the CFG} ) \: \{    \\
    &    \quad \quad \quad \quad \text{Out}_{B} = \land_{\text{successors} \, S \, \text{of} \,  B} \, \text{In}_{S};    \\
    &    \quad \quad \quad \quad \text{In}_{B} \phantom{O} = F_{B}(Out_{B});    \\
    &    \quad \quad \}    \\
    &    \}   
    \end{align}
</p>

<p>We initialise the boundary \(\text{Out}(\small{\text{EXIT}})\). References to \(\text{In}\) have been replaced with \(\text{Out}\) and vice-versa, and instead of taking the meet (or \(\land\)) over a node's predecessors, we calculate it from that node's {{#definition "successor"}}successors{{/definition}}.</p>
