<p class="lesson-generic-description">Previously, we have seen the {{#definition "transfer_function"}}transfer function{{/definition}} defined as \(\small{\text{Out}(n)}\) in terms of \(\small{\text{In}(n)}\) and {{#definition "local_information"}}local information{{/definition}}. In generic frameworks we define a <strong>set</strong> of transfer functions \(\small{F}\), one for <strong>each</strong> block, \(\small{B}\), of code. Each block is the same as a <strong>node</strong> in the CFG. For example, \[ \small{\text{Out}(n_0) = \text{DefGen}(n_0) \cup (\text{In}(n_0) \setminus \text{DefKill}(n_0))}\] becomes \[\small{F_{n_0}(x) = \text{DefGen}_{n_0} \cup (x \setminus \text{DefKill}_{n_0})}\] in our generic reaching definitions framework. \(x\), in this case, would be \(\small{\text{In}(n_0)}\). We will see why this is important later.</p>
